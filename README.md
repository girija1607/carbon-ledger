# Carbon Ledger API - Project Reflection

## 1. How did you design the ID so itâ€™s always the same for the same input?
The ID is deterministic because it's generated by hashing a **canonical representation** of the input data. We created a consistent string by sorting the input object's keys alphabetically before hashing it with SHA-256. This ensures that even if the input fields are in a different order, the resulting string is always the same, thus producing the same ID.

## 2. Why did you use an event log instead of updating the record directly?
An event log provides **immutability and a complete audit trail**. Instead of overwriting a status, we record new facts as they happen (e.g., "created," "retired"). This is crucial for a ledger system where transparency and history are important. You can always reconstruct the state of a credit at any point in time by replaying its events.

## 3. If two people tried to retire the same credit at the same time, what would break?
This would create a **race condition**. Both requests could simultaneously read the record, see it as "Active," and then both create a "retired" event. This would result in the credit being retired twice in the database, corrupting the data and potentially allowing the same credit to be counted twice.

## 4. How would you fix it?
The best way to fix this is with **atomic operations** at the database level.
* **Unique Index/Constraint:** A more robust solution is to add a unique constraint to the database that prevents more than one "retired" event for the same `record_id`. The first request would succeed, and the second would fail with a database error, which the application can handle gracefully.
* **Database Locking:** Another approach is to use a transaction with a `SELECT ... FOR UPDATE` statement. This locks the record, forcing the second request to wait until the first one is finished. By the time the second request gets access, it will see the credit is already retired and can abort.